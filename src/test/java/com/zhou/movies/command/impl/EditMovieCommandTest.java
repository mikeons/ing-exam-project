package com.zhou.movies.command.impl;

import com.zhou.movies.dto.MovieDTO;
import com.zhou.movies.pojo.Movie;
import com.zhou.movies.service.MovieService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for EditMovieCommand
 * Goal: verify command manages Original and Updated Mementos correctly
 */
@ExtendWith(MockitoExtension.class)
class EditMovieCommandTest {

    @Mock
    private MovieService mockService;

    private Movie fakeOriginalMovie; // Original Memento
    private Movie fakeUpdatedMovie;  // Updated Memento
    private MovieDTO testDTO;        // DTO data
    private String randomId;         // store autogenerated ID

    private EditMovieCommand editMovieCommand;

    @BeforeEach
    void setUp() {
        testDTO = new MovieDTO("Updated Title", "Updated Director", "2025", null, null, 5);

        // Original Memento with random ID
        fakeOriginalMovie = new Movie.Builder("Original Title", "Original Director")
                .year(2000)
                .build();
        randomId = fakeOriginalMovie.getId();

        // Updated Memento inherits the same ID
        fakeUpdatedMovie = fakeOriginalMovie.toBuilder()
                .title("Updated Title")
                .director("Updated Director")
                .year(2025)
                .rating(5)
                .build();

        editMovieCommand = new EditMovieCommand(mockService, fakeOriginalMovie, testDTO);
    }

    @Test
    @DisplayName("Execute should call service.editMovie and store Updated Memento")
    void execute_WhenCalled_ShouldCallServiceAndStoreUpdatedMemento() throws Exception {
        when(mockService.editMovie(randomId, testDTO)).thenReturn(fakeUpdatedMovie);

        editMovieCommand.execute();

        verify(mockService, times(1)).editMovie(randomId, testDTO); // verify service call
        assertEquals(fakeUpdatedMovie, editMovieCommand.getUpdatedMovie()); // updated stored
        assertEquals(fakeOriginalMovie, editMovieCommand.getOriginalMovie()); // original still stored
        assertEquals(randomId, editMovieCommand.getUpdatedMovie().getId()); // ID unchanged
    }

    @Test
    @DisplayName("Undo after execute should call service.replaceMovie with Original Memento")
    void undo_AfterExecute_ShouldCallServiceReplaceWithOriginalMemento() throws Exception {
        when(mockService.editMovie(randomId, testDTO)).thenReturn(fakeUpdatedMovie);
        editMovieCommand.execute();

        editMovieCommand.undo();

        verify(mockService, times(1)).updateMovie(fakeOriginalMovie); // verify original restored
    }

    @Test
    @DisplayName("Execute should propagate service exception and not store Updated Memento")
    void execute_WhenServiceFails_ShouldPropagateExceptionAndNotStoreMemento() throws Exception {
        when(mockService.editMovie(anyString(), any(MovieDTO.class)))
                .thenThrow(new Exception("Movie not found"));

        Exception exception = assertThrows(Exception.class, () -> editMovieCommand.execute());

        assertEquals("Movie not found", exception.getMessage()); // exception propagated
        assertNull(editMovieCommand.getUpdatedMovie()); // updated not stored
    }
}
